---
layout: post
title: "JWT-无状态的安全鉴权机制"
description: "前后端分离场景下，鉴权机制的选择，jwt即JSON Web Tokens"
categories: [jwt, nodejs]
tags: [jwt, nodejs, auth]
redirect_from:
  - /2016/12/30/
---

[待修订！]

> 前后端分离场景下，鉴权机制的选择，jwt即JSON Web Tokens。

* Kramdown table of contents
{:toc .toc}

## 引子

很长一段时间里，我不知道如何进行端到端的与设备无关的通讯。当然这已不是传统上的客户端cookie与服务端session的概念，更何况cookie在移动设备上支持是乏力的，更何况要面对N多端呢！

在此之前我了解到应该使用一种叫token的认证机制，从服务器获取一串字符，然后不论在何种终端设备上访问服务器时，只要携带这个token就行了。至于验证，交给服务器来做。

当然，这些机制通常用在API的设计中，这些设计应该是无状态的，没有登陆注册，只有信息交换。

## 其他机制

在开始介绍JWT之前，我们先来说一些其他的鉴权机制。

### OAuth

OAuth协议为用户资源的授权提供了一个安全的、开放而又简易的标准。主要就是进行第三方网站授权，平时我们用的最多的是使用qq或github账户登陆其他网站。这对用户来说是比较方便的，对于网站来说实现起来即简单又安全。用户身份的验证交给第三方网站，如果用户通过了第三方的验证，那么我们就可以认为该用户是合法的。与以往的授权方式不同之处是OAuth的授权不会使第三方触及到用户的帐号信息，如用户名与密码，即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAuth是安全的。

那么为什么现在没有立即使用这种解决方案呢？

原因很简单，我搞明白了大致的思路，但在代码里如何实现，还没有写出来．第二，OAuth提供的主要是国外流行的网站，而国内常用的qq/微信应该需要使用第三方的代码，网上是能找到的．不过现在的重点不是这里，qq/微信的登陆后期也是需要做的，研究明白了再来补充．

## JWT方案

废话了一大通，现在来说一说JWT.
JWT的全称是json web token，有json有token,
JWT的主要功能是，身份验证，信息交换，用在这里合适．
很多语言有JWT的实现，https://jwt.io/

> JWT是一种用于双方之间传递安全信息的简洁的、URL安全的表述性声明规范。JWT作为一个开放的标准（ RFC 7519 ），定义了一种简洁的，自包含的方法用于通信双方之间以Json对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。

## 分解JWT

JWT分为三段，第一段，用来描述这个token类型以及使用的hash算法，第二段是请求的实体，可以携带一些用户信息，第三段，根据第一部分和第二部分的签名．
首先第一段是这个token的类型及算法，没啥说的．重点在第二段，这一段信息是使用base64编码的，可以包含一些公开的对安全没有影响的数据，一般的用户信息可以写进去，用户名，角色什么的．当然密码肯定不能写进去．base64解码便能看到所有信息，就不好了．第三段的签名是根据特定的算法生成的，需要在服务端配合私钥进行解码．

## 使用JWT

如何生成/存在哪里？
在注册时生成token，存入数据库．
现在暂未考虑token的生存期的问题，当然有生存期的存在更合理更安全，操作起来有些麻烦．

生成token时，要额外注意的是存在服务端的私钥，要妥善保管，在部署时需要修改，很明显有一种把所有都压在这里的感觉．

```
// sign with default (HMAC SHA256)
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

如何使用呢？
JWT是要在请求头中传递的，所以首先要在请求头中增加自定义的请求头:
`'Access-Control-Allow-Headers',
    'X-Requested-With,content-type, Authorization'`
每次客户端请求时，携带token,服务端利用中间件获取token并验证．
Bearer Token是携带的token的一种格式：
`Bearer XXXXXXXX`

## 思考

需要注意：
如果我伪造token怎么办那？这一点不用担心，这个token是不能伪造的，修改了其中的任意值，第三段的签名就会变，验证就无法通过．

当中间件截获了token，并不能信任这个token,需要进行验证，`jwt.verify()`，当然紧接着的是查询数据库是否有这个token，如果忽略了这个操作，那么之前的工作就白费了．
我随便传个或伪造个token你不经过验证就通过了，很可怕的．或者说，加密的私钥泄漏了，我按着你的加密流程走一遍，得到的token也能通过你的验证，所以这时候，再去数据库里确认一下就显得十分重要了．
安全无小事嘛！

```
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar
```


